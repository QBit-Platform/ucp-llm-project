# ucp_llm.py
# Copyright (c) 2024 Sameh Yassin
# All rights reserved.
#
# This project, "UCP-LLM (User Context Protocol for Large Language Models)",
# including its conceptual framework, HTML generator, Python library,
# and GUI manager, is the intellectual property of Sameh Yassin.
#
# Version: 1.0.0

import json
from typing import List, Dict, Any, Optional

class UCPProfile:
    """
    Loads, parses, and provides access to a User Context Protocol (UCP-LLM)
    JSON file, generated by the UCP-LLM Generator HTML tool (v1.0.0 English version).
    This library expects JSON keys within item objects to be English (jsonKey from HTML).
    """

    def __init__(self, file_path: str):
        self.file_path = file_path
        self.raw_data: Optional[Dict[str, Any]] = None
        self.error_message: Optional[str] = None
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                self.raw_data = json.load(f)
            if not isinstance(self.raw_data, dict) or \
               "sections" not in self.raw_data or \
               not isinstance(self.raw_data.get("sections"), list) or \
               "protocolVersion" not in self.raw_data:
                self.error_message = "Invalid UCP-LLM JSON structure: Core keys like 'protocolVersion' or 'sections' list are missing or malformed."
                self.raw_data = None
        except FileNotFoundError:
            self.error_message = f"Error: File not found at {file_path}"
        except json.JSONDecodeError as e:
            self.error_message = f"Error: Could not decode JSON. Details: {e}"
        except Exception as e:
            self.error_message = f"An unexpected error occurred: {e}"

    def is_valid(self) -> bool:
        return self.raw_data is not None and self.error_message is None

    def get_error(self) -> Optional[str]:
        return self.error_message

    def get_raw_data(self) -> Optional[Dict[str, Any]]:
        return self.raw_data if self.is_valid() else None

    def get_generator_tool_version(self) -> Optional[str]:
        if not self.is_valid() or self.raw_data is None: return None
        return self.raw_data.get("protocolVersion")

    def get_generation_date(self) -> Optional[str]:
        if not self.is_valid() or self.raw_data is None: return None
        return self.raw_data.get("generationDate")

    def get_sections(self) -> List[Dict[str, Any]]:
        if not self.is_valid() or self.raw_data is None: return []
        sections_data = self.raw_data.get("sections", [])
        return sections_data if isinstance(sections_data, list) else []

    def get_section_by_id(self, section_id: str) -> Optional[Dict[str, Any]]:
        if not self.is_valid(): return None
        for section in self.get_sections():
            if isinstance(section, dict) and section.get("id") == section_id:
                return section
        return None

    def get_section_title(self, section_id: str) -> Optional[str]:
        section = self.get_section_by_id(section_id)
        return section.get("title") if section else None

    def get_section_items(self, section_id: str) -> List[Dict[str, Any]]:
        section = self.get_section_by_id(section_id)
        items_data = section.get("items", []) if section else []
        return [item for item in items_data if isinstance(item, dict)] if isinstance(items_data, list) else []

    def get_first_item_from_section(self, section_id: str) -> Optional[Dict[str, Any]]:
        items = self.get_section_items(section_id)
        return items[0] if items else None

    def get_value_from_item(self, item: Optional[Dict[str, Any]], json_key: str, default: Any = None) -> Any:
        return item.get(json_key, default) if isinstance(item, dict) else default

    def get_value_from_first_item(self, section_id: str, json_key: str, default: Any = None) -> Any:
        item = self.get_first_item_from_section(section_id)
        return self.get_value_from_item(item, json_key, default)

    # --- Comprehensive Getters for ALL 25 sections defined in HTML Tool sectionTypeData ---
    # The jsonKey used here MUST match the jsonKey defined in your HTML's sectionTypeData

    # 1. Personal Data (id: personal)
    def get_personal_preferred_name(self) -> Optional[str]: return self.get_value_from_first_item("personal", "preferredName")
    def get_personal_date_of_birth(self) -> Optional[str]: return self.get_value_from_first_item("personal", "dateOfBirth")
    def get_personal_nationality(self) -> Optional[str]: return self.get_value_from_first_item("personal", "nationalityCulturalBackground")
    def get_personal_languages(self) -> Optional[str]: return self.get_value_from_first_item("personal", "languagesProficiency")

    # 2. Social and Family Status (id: social)
    def get_social_details(self) -> Optional[str]: return self.get_value_from_first_item("social", "socialFamilyDetails")

    # 3. Educational & Professional Background (id: educational_professional)
    def get_edu_prof_education(self) -> Optional[str]: return self.get_value_from_first_item("educational_professional", "educationalBackground")
    def get_edu_prof_experience(self) -> Optional[str]: return self.get_value_from_first_item("educational_professional", "professionalExperience")

    # 4. Core Thinking Reference (id: thinking_reference)
    def get_thinking_ref_description(self) -> Optional[str]: return self.get_value_from_first_item("thinking_reference", "coreThinkingReferenceDescription")
    def get_thinking_ref_application(self) -> Optional[str]: return self.get_value_from_first_item("thinking_reference", "thinkingReferenceApplication")

    # 5. Cognitive Passion & Research Patterns (id: cognitive_passion) - Multiple Items
    def get_all_cognitive_passions(self) -> List[Dict[str, Any]]: return self.get_section_items("cognitive_passion")

    # 6. Guiding Ethical Values (id: ethical_values) - Multiple Items
    def get_all_ethical_values(self) -> List[Dict[str, Any]]: return self.get_section_items("ethical_values")

    # 7. Perspective on Core Concepts (id: concepts_perspective) - Multiple Items
    def get_all_concepts_perspectives(self) -> List[Dict[str, Any]]: return self.get_section_items("concepts_perspective")

    # 8. Methodology for Cognitive Tools (id: cognitive_tools_methodology) - Multiple Items
    def get_all_cognitive_tools_methodologies(self) -> List[Dict[str, Any]]: return self.get_section_items("cognitive_tools_methodology")

    # 9. Inspiring Human Models/Figures (id: inspiring_figures) - Multiple Items
    def get_all_inspiring_figures(self) -> List[Dict[str, Any]]: return self.get_section_items("inspiring_figures")

    # 10. Intellectual Sins/Biases to Avoid (id: intellectual_sins) - Multiple Items
    def get_all_intellectual_sins(self) -> List[Dict[str, Any]]: return self.get_section_items("intellectual_sins")

    # 11. Projects & Objectives (id: projects) - Multiple Items (merged from 'projects' and 'goals')
    def get_all_projects_objectives(self) -> List[Dict[str, Any]]: return self.get_section_items("projects")

    # 12. Pivotal Examples (id: pivotal_examples) - Multiple Items
    def get_all_pivotal_examples(self) -> List[Dict[str, Any]]: return self.get_section_items("pivotal_examples")

    # 13. Causal Relations Between Concepts (id: causal_relations) - Multiple Items
    def get_all_causal_relations(self) -> List[Dict[str, Any]]: return self.get_section_items("causal_relations")

    # 14. LLM Functional Persona (id: role)
    def get_llm_persona_primary_role(self) -> Optional[str]: return self.get_value_from_first_item("role", "llmPrimaryRole")
    def get_llm_persona_attributes(self) -> Optional[str]: return self.get_value_from_first_item("role", "llmRoleAttributes")

    # 15. Conceptual Tuning (User-Specific Terms) (id: conceptual_tuning) - Multiple Items
    def get_all_conceptual_tunings(self) -> List[Dict[str, Any]]: return self.get_section_items("conceptual_tuning")

    # 16. Preferred Interaction Style (id: interaction_style)
    def get_interaction_preferred_style(self) -> Optional[str]: return self.get_value_from_first_item("interaction_style", "preferredResponseStyle")
    def get_interaction_styles_to_avoid(self) -> Optional[str]: return self.get_value_from_first_item("interaction_style", "stylesToAvoid")

    # 17. Model Intervention Level (id: intervention_level)
    def get_intervention_chosen_level(self) -> Optional[str]: return self.get_value_from_first_item("intervention_level", "chosenInterventionLevel")
    def get_intervention_clarifications(self) -> Optional[str]: return self.get_value_from_first_item("intervention_level", "interventionClarifications")

    # 18. Desired Alignment Level (id: alignment_level)
    def get_alignment_desired_level(self) -> Optional[str]: return self.get_value_from_first_item("alignment_level", "desiredAlignmentLevel")
    def get_alignment_level_notes(self) -> Optional[str]: return self.get_value_from_first_item("alignment_level", "alignmentLevelNotes")

    # 19. Mechanism for Requesting/Receiving Critique (id: critique_mechanism)
    def get_critique_preferences(self) -> Optional[str]: return self.get_value_from_first_item("critique_mechanism", "critiquePreferences")
    def get_critique_conditions(self) -> Optional[str]: return self.get_value_from_first_item("critique_mechanism", "critiqueConditions")

    # 20. Prohibitions and Warnings for LLM (id: constraints_warnings) - Multiple Items
    def get_all_constraints_warnings(self) -> List[Dict[str, Any]]: return self.get_section_items("constraints_warnings")

    # 21. Memory Management Directives (id: memory_management_directives)
    def get_memory_context_directive(self) -> Optional[str]: return self.get_value_from_first_item("memory_management_directives", "contextMaintenanceDirective")
    def get_memory_protocol_recall(self) -> Optional[str]: return self.get_value_from_first_item("memory_management_directives", "protocolRecallMechanism")

    # 22. Cognitive/Behavioral Preferences (id: cognitive_preferences)
    def get_cognitive_behavioral_preference(self) -> Optional[str]: return self.get_value_from_first_item("cognitive_preferences", "cognitiveBehavioralPreference")

    # 23. Mental State (Optional & Updatable) (id: mental_state)
    def get_mental_state_selected(self) -> Optional[str]: return self.get_value_from_first_item("mental_state", "selectedMentalState")
    def get_mental_state_notes(self) -> Optional[str]: return self.get_value_from_first_item("mental_state", "mentalStateNotes")

    # 24. Sports Inclinations (id: sports_inclinations)
    def get_sports_chosen_inclination(self) -> Optional[str]: return self.get_value_from_first_item("sports_inclinations", "chosenSportInclination")
    def get_sports_other_details(self) -> Optional[str]: return self.get_value_from_first_item("sports_inclinations", "sportOtherDetails")

    # 25. Additional General Notes (id: additional_notes)
    def get_additional_general_notes(self) -> Optional[str]: return self.get_value_from_first_item("additional_notes", "additionalGeneralNotes")


# --- Example Usage for testing the library ---
if __name__ == "__main__":
    # Create a mock JSON file with a subset of sections and English keys
    # This should ideally be replaced by loading an actual file generated by your HTML tool
    mock_data = {
        "protocolVersion": "UCP-LLM Generator v1.0.0",
        "generationDate": "2024-05-15T12:00:00Z",
        "sections": [
            {
                "id": "personal", "title": "👤 Personal Data",
                "items": [{"preferredName": "Test User", "languagesProficiency": "English, Arabic"}]
            },
            {
                "id": "thinking_reference", "title": "🧠 Core Thinking Reference",
                "items": [{"coreThinkingReferenceDescription": "Logical Positivism", 
                           "thinkingReferenceApplication": "Applied to scientific inquiry."}]
            },
            {
                "id": "projects", "title": "📌 Projects & Objectives",
                "items": [
                    {"projectOrObjectiveTitle": "Develop UCP Library", "projectGoals": "Complete Python library for UCP parsing."},
                    {"projectOrObjectiveTitle": "Build GUI", "projectLLMRole": "Assist with Tkinter"}
                ]
            },
            {
                "id": "ethical_values", "title": "⚖️ Guiding Ethical Values",
                "items": [
                    {"ethicalValueName": "Integrity", "ethicalValueExplanation": "Adherence to moral principles."},
                    {"ethicalValueName": "Objectivity", "ethicalValueExplanation": "Striving for unbiased analysis."}
                ]
            }
        ]
    }
    test_file_path = "comprehensive_test_ucp.json"
    with open(test_file_path, "w", encoding="utf-8") as f:
        json.dump(mock_data, f, ensure_ascii=False, indent=2)

    print(f"--- Testing ucp_llm.py with comprehensive mock file: {test_file_path} ---")
    profile = UCPProfile(test_file_path)

    if profile.is_valid():
        print(f"Generator Tool Version: {profile.get_generator_tool_version()}")
        print(f"Preferred Name: {profile.get_personal_preferred_name()}")
        print(f"Languages: {profile.get_personal_languages()}")
        print(f"Thinking Ref Desc: {profile.get_thinking_ref_description()}")

        projects = profile.get_all_projects_objectives()
        if projects:
            print(f"\nProjects/Objectives ({len(projects)}):")
            for i, p_item_dict in enumerate(projects):
                print(f"  Project {i+1} Title: {profile.get_value_from_item(p_item_dict, 'projectOrObjectiveTitle')}")
                print(f"    Goals: {profile.get_value_from_item(p_item_dict, 'projectGoals')}") # Will be None if key not in item
                print(f"    LLM Role: {profile.get_value_from_item(p_item_dict, 'projectLLMRole')}") # Will be None if key not in item


        ethical_values = profile.get_all_ethical_values()
        if ethical_values:
            print(f"\nEthical Values ({len(ethical_values)}):")
            for i, val_item_dict in enumerate(ethical_values):
                print(f"  Value {i+1} Name: {profile.get_value_from_item(val_item_dict, 'ethicalValueName')}")
                print(f"    Explanation: {profile.get_value_from_item(val_item_dict, 'ethicalValueExplanation')}")
        
        # Example of accessing a section that might not be in the mock data
        mental_state = profile.get_mental_state_selected()
        print(f"\nMental State Selected: {mental_state if mental_state else 'Not specified in test file'}")


    else:
        print(f"Error loading profile from {test_file_path}: {profile.get_error()}")
